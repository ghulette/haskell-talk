%!TEX root=fp-intro.tex

\section{First-order functions}

%
\begin{frame}[fragile]{Simple functions}

Functions in Haskell are abstractions in the $\lambda$-calculus. 

Think of functions as expressions with missing bits, which are represented by
the inputs.

\end{frame}

% How does the lambda calculus turn into functions?
% Notice everything we don't have - mutable data, side effects, state.

%
\begin{frame}[fragile]{Example}

Here is a very simple Haskell function which doubles a number:

\begin{block}{}
\begin{verbatim}
double x = 2 * x
\end{verbatim}
\end{block}

Or, equivalently:

\begin{block}{}
\begin{verbatim}
double = \x -> 2 * x
\end{verbatim}
\end{block}

\end{frame}

%
\begin{frame}[fragile]{Example}

We can (and often do) provide an explicit type for top-level functions:

\begin{verbatim}
double :: Int -> Int
double x = 2 * x
\end{verbatim}

Haskell will infer the type anyway, and check that it matches your annotation.

\end{frame}

%
\begin{frame}[fragile]{Anonymous functions}

Functions can be defined and used anywhere, just like any other value.

\end{frame}

%
\begin{frame}[fragile]{Pattern matching}

Function using pattern matching.

\end{frame}

%
\begin{frame}[fragile]{Multiple arguments}

Functions with multiple arguments.

\end{frame}

%
\begin{frame}[fragile]{Partial application}

Currying.

% It looks like the -> is separating the arguments to dropWhile from each other,
% but that it also separates the arguments from the return type. In fact -> has
% only one meaning: it denotes a function that takes an argument of the type on
% the left and returns a value of the type on the right.

% The implication here is very important. In Haskell, all functions take only
% one argument. While dropWhile looks like a function that takes two arguments,
% it is actually a function of one argument, which returns a function that takes
% one argument. Hereâ€™s a perfectly valid Haskell expression:

\begin{verbatim}
niceSum :: [Integer] -> Integer
niceSum xs = foldl (+) 0 xs

nicerSum :: [Integer] -> Integer
nicerSum = foldl (+) 0
\end{verbatim}

\end{frame}

%
\begin{frame}[fragile]{Lazy evaluation}

Lazy functions.

\end{frame}

%
\begin{frame}[fragile]{Recursion}

Recursion.

\end{frame}

