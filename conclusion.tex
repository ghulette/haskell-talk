%!TEX root=fp-intro.tex

\section{Conclusion}

%
\begin{frame}{More stuff!}

We barely scratched the surface. In the future I would like to talk about:

\end{frame}

%
\begin{frame}[fragile]{The Curry-Howard Isomorpism}

The type signature

\begin{block}{}
\begin{verbatim}
(b -> c) -> (a -> b) -> (a -> c)
\end{verbatim}
\end{block}

can be interpreted as a logical proposition

\begin{block}{}
\[
(b \implies c) \implies (a \implies b) \implies (a \implies c)
\]
\end{block}

for all $a$, $b$, and $c$. The Haskell function

\begin{block}{}
\begin{verbatim}
(.) :: (b -> c) -> (a -> b) -> (a -> c)
f . g = f (g x)
\end{verbatim}
\end{block}

is a proof that this statement is true.

\end{frame}

%
\begin{frame}[fragile]{Imperative programming}

In this talk we have stayed away from things like reading files or printing
output.

Since Haskell is evaluated non-strictly, ordering these kinds of side-effecting
operations is a problem.

\begin{block}{}
\begin{verbatim}
map print [1..5]
\end{verbatim}
\end{block}

You might expect this to print out one through five in order, but why? Why not
backwards, or any order?

\end{frame}

%
\begin{frame}[fragile]{Imperative programming}

Haskell has an extremely clever solution -- \textbf{monads}.

Monads are lifted from category theory, and control ordering of side-effects
while preserving all the nice properties (purity, composition) that we have
seen.

Monads turn out to be useful in many contexts besides IO -- they are a useful
link between imperative and functional programming.

\end{frame}

%
\begin{frame}{Conclusion}

Questions?

My email: \texttt{ghulett@sandia.gov}

\end{frame}
