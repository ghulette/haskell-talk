%!TEX root=fp-intro.tex

\section{Conclusion}

%
\begin{frame}{More stuff!}

In the future I would like to talk about:

\end{frame}

%
\begin{frame}[fragile]{The Curry-Howard Isomorpism}

The type signature

\begin{block}{}
\begin{verbatim}
(b -> c) -> (a -> b) -> (a -> c)
\end{verbatim}
\end{block}

can be interpreted as a logical proposition

\begin{block}{}
\[
(b \implies c) \implies (a \implies b) \implies (a \implies c)
\]
\end{block}

for all $a$, $b$, and $c$. The Haskell function

\begin{block}{}
\begin{verbatim}
(.) :: (b -> c) -> (a -> b) -> (a -> c)
f . g = f (g x)
\end{verbatim}
\end{block}

is a proof of the theorem.

\end{frame}

%
\begin{frame}[fragile]{Imperative programming}

So far, we have avoided things like reading files or printing output.

Since Haskell is evaluated non-strictly, ordering operations is a problem.

\begin{block}{}
\begin{verbatim}
map print [1..5]
\end{verbatim}
\end{block}

You might expect this to print out one through five in order, but why? Why not
backwards, or any other order?

\end{frame}

%
\begin{frame}[fragile]{Imperative programming}

Haskell uses an extremely clever solution -- \textbf{monads}.

Monads are borrowed from category theory, and control ordering of side-effects
while preserving all the nice properties (purity, composition) that we have
seen.

Monads turn out to be useful in many contexts besides IO -- they are a link
between the imperative and functional programming worlds.

\end{frame}

%
\begin{frame}{Conclusion}

Questions?

My email: \texttt{ghulett@sandia.gov}

\end{frame}
